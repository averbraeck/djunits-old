package org.djunits.value.vfloat.scalar;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.djunits.unit.AbsoluteTemperatureUnit;
import org.djunits.unit.LengthUnit;
import org.djunits.unit.PositionUnit;
import org.djunits.unit.TemperatureUnit;
import org.djunits.unit.Unit;
import org.junit.Test;

/**
 * Test the FloatScalar class.
 * <p>
 * This file was generated by the djunits value test classes generator, 26 jun, 2015
 * <p>
 * Copyright (c) 2015-2019 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="https://djunits.org/docs/license.html">DJUNITS License</a>.
 * <p>
 * $LastChangedDate$, @version $Revision$, by $Author$,
 * initial version 26 jun, 2015 <br>
 * @author <a href="https://www.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="https://www.tudelft.nl/staff/p.knoppers/">Peter Knoppers</a>
 */
public class FloatScalarTest
{
    /**
     * Check that the value in a FloatScalarmatches the expected value.
     * @param fs FloatScalar&lt;?&gt;; the FloatScalar to match
     * @param reference float; the reference value
     * @param precision float; the maximum allowed error
     * @param u Unit&lt;?&gt;; the expected type
     * @param expectAbsolute boolean; if true; fs should be Absolute; if false; fs should be Relative
     */
    private static void checkContentsAndType(final AbstractFloatScalar<?, ?> fs, final float reference, final float precision,
            final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue("FloatScalar should not be null", null != fs);
        assertEquals("Value should match", reference, fs.getInUnit(), precision);
        assertEquals("Unit should be " + u.toString(), u, fs.getUnit());
        assertTrue("Should be " + (expectAbsolute ? "Absolute" : "Relative"),
                expectAbsolute ? fs.isAbsolute() : fs.isRelative());
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringAbsTest()
    {
        AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.KELVIN;
        float value = 38.0f;
        FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit> fs =
                new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit);
        String result = fs.toString(true, true);
        assertTrue("toString result contains \"Abs \"", result.contains("Abs "));
        assertTrue("toString result contains \"K\"", result.contains("K"));
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @Test
    public final void basicsAbsTest()
    {
        AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit> temperatureFS =
                new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit);
        checkContentsAndType(temperatureFS, value, 0.001f, tempUnit, true);
        assertEquals("Value in SI is equivalent in Kelvin", 311.15f, temperatureFS.getSI(), 0.05);
        assertEquals("Value in Fahrenheit", 100.4f, temperatureFS.getInUnit(AbsoluteTemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
        float out = temperatureFS.getInUnit();
        assertEquals("Value should match", value, out, 0.001);
        FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit> mfs =
                new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, true);
        mfs = new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(-200, tempUnit);
        assertEquals("-200 Celsius roughly equivalent to 73 Kelvin", 73.0d, mfs.si, 1.0d);
        FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit> temperature2FS =
                new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(temperatureFS);
        assertTrue("temperature2FS should be equal to temperatureFS", temperature2FS.equals(temperatureFS));
        assertTrue("Value is Absolute", temperatureFS.isAbsolute());
        assertFalse("Value is not Relative", temperatureFS.isRelative());
        temperatureFS = new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, AbsoluteTemperatureUnit.KELVIN);
        checkContentsAndType(temperatureFS, value, 0.001f, AbsoluteTemperatureUnit.KELVIN, true);
        out = temperatureFS.getSI();
        assertEquals("Value should match", value, out, 0.001);
        for (int i = -100; i <= 100; i++)
        {
            float v = i / 10.0f;
            mfs = new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(v, AbsoluteTemperatureUnit.BASE);
            assertEquals("intValue should round like Math.round", Math.round(v), mfs.intValue(), 0.0001);
            assertEquals("longValue should round like Math.round", Math.round(v), mfs.longValue(), 0.0001);
            assertEquals("floatValue should return the value", v, mfs.floatValue(), 0.0001);
            assertEquals("doubleValue should return the value", v, mfs.doubleValue(), 0.0001);
        }
    }

    /**
     * Test the equals method.
     */
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        PositionUnit positionUnit = PositionUnit.BASE;
        float value = 38.0f;
        FloatScalar.Abs<PositionUnit, LengthUnit> fs = new FloatScalar.Abs<PositionUnit, LengthUnit>(value, positionUnit);
        assertTrue("Equal to itself", fs.equals(fs));
        assertFalse("Not equal to null", fs.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", fs.equals(new String("abc")));
        FloatScalar.Rel<LengthUnit> fsCounterPart = new FloatScalar.Rel<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", fs.equals(fsCounterPart));
        FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit> fsWrongBaseUnit =
                new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, AbsoluteTemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", fs.getSI(), fsWrongBaseUnit.getSI(), 0.0001f);
        assertFalse("Not equals because the standard SI unit differs", fs.equals(fsWrongBaseUnit));
        FloatScalar.Abs<PositionUnit, LengthUnit> fsCompatibleUnit =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(38000.0f, PositionUnit.MILLIMETER);
        assertFalse("Units are different", fs.getUnit().equals(fsCompatibleUnit.getUnit()));
        assertTrue("equals returns true", fs.equals(fsCompatibleUnit));
        FloatScalar.Abs<PositionUnit, LengthUnit> fsDifferentValue =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(123.456f, PositionUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", fs.equals(fsDifferentValue));
    }

    /**
     * Test the relational operations.
     */
    @Test
    public final void relOpAbsTest()
    {
        FloatScalar.Abs<PositionUnit, LengthUnit> base =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(123, PositionUnit.KILOMETER);
        FloatScalar.Abs<PositionUnit, LengthUnit> same =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(123000, PositionUnit.METER);
        FloatScalar.Abs<PositionUnit, LengthUnit> smaller =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(122999, PositionUnit.METER);
        FloatScalar.Abs<PositionUnit, LengthUnit> larger =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(123001, PositionUnit.METER);
        assertFalse("123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertTrue("123km == 123000m", base.eq(same));
        assertFalse("NOT 123km != 123000m", base.ne(same));
        assertTrue("123km < 123001m", base.lt(larger));
        assertTrue("123km > 122999m", base.gt(smaller));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertFalse("NOT 123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km != 123001m", base.ne(larger));
        assertFalse("NOT 123km == 123001m", base.eq(larger));
        assertTrue("123km != 122999m", base.ne(smaller));
        assertFalse("NOT 123km == 122999m", base.eq(smaller));
        assertFalse("NOT 123km >= 123001m", base.ge(larger));
        assertFalse("NOT 123km <= 122999m", base.le(smaller));
    }

    /**
     * Test the Math functions.
     */
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        float[] seedValues = { -10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f };
        for (float seedValue : seedValues)
        {
            float input = seedValue;
            FloatScalar.Abs<PositionUnit, LengthUnit> fs;
            fs = new FloatScalar.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER);
            MathTester.tester(input, "ceil", fs.ceil(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.ceil(f);
                }
            });
            fs = new FloatScalar.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER);
            MathTester.tester(input, "floor", fs.floor(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.floor(f);
                }
            });
            fs = new FloatScalar.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER);
            MathTester.tester(input, "rint", fs.rint(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.rint(f);
                }
            });
            fs = new FloatScalar.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER);
            MathTester.tester(input, "round", fs.round(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.round(f);
                }
            });
        }
    }

    /**
     * Test plus(FloatScalarAbs, FloatScalarRel).
     */
    @Test
    public final void binaryplusOfAbsAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Abs<PositionUnit, LengthUnit> left =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(leftValue, PositionUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        FloatScalar.Abs<PositionUnit, LengthUnit> result = FloatScalar.plus(left, right);
        assertEquals("value of element should be SI plus of contributing elements", left.getSI() + right.getSI(),
                result.getSI(), 0.001f);
    }

    /**
     * Test minus(FloatScalarAbs, FloatScalarRel).
     */
    @Test
    public final void binaryminusOfAbsAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Abs<PositionUnit, LengthUnit> left =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(leftValue, PositionUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        FloatScalar.Abs<PositionUnit, LengthUnit> result = FloatScalar.minus(left, right);
        assertEquals("value of element should be SI minus of contributing elements", left.getSI() - right.getSI(),
                result.getSI(), 0.001f);
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        float value = 38.0f;
        FloatScalar.Rel<TemperatureUnit> fs = new FloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        String result = fs.toString(true, true);
        assertTrue("toString result contains \"Rel \"", result.contains("Rel "));
        assertTrue("toString result contains \"K\"", result.contains("K"));
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @Test
    public final void basicsRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        FloatScalar.Rel<TemperatureUnit> temperatureFS = new FloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(temperatureFS, value, 0.001f, tempUnit, false);
        assertEquals("Value in SI is equivalent in Kelvin", 38.0f, temperatureFS.getSI(), 0.05);
        assertEquals("Value in Fahrenheit", 38.0f * 9.0f / 5.0f, temperatureFS.getInUnit(TemperatureUnit.DEGREE_FAHRENHEIT),
                0.1);
        float out = temperatureFS.getInUnit();
        assertEquals("Value should match", value, out, 0.001);
        FloatScalar.Rel<TemperatureUnit> mfs = new FloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, false);
        assertTrue("Value is Relative", temperatureFS.isRelative());
        assertFalse("Value is not Absolute", temperatureFS.isAbsolute());
        temperatureFS = new FloatScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        checkContentsAndType(temperatureFS, value, 0.001f, TemperatureUnit.KELVIN, false);
        out = temperatureFS.getSI();
        assertEquals("Value should match", value, out, 0.001);
        for (int i = -100; i <= 100; i++)
        {
            float v = i / 10.0f;
            mfs = new FloatScalar.Rel<TemperatureUnit>(v, TemperatureUnit.SI);
            assertEquals("intValue should round like Math.round", Math.round(v), mfs.intValue(), 0.0001);
            assertEquals("longValue should round like Math.round", Math.round(v), mfs.longValue(), 0.0001);
            assertEquals("floatValue should return the value", v, mfs.floatValue(), 0.0001);
            assertEquals("doubleValue should return the value", v, mfs.doubleValue(), 0.0001);
        }
    }

    /**
     * Test the equals method.
     */
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        PositionUnit positionUnit = PositionUnit.BASE;
        float value = 38.0f;
        FloatScalar.Rel<LengthUnit> fs = new FloatScalar.Rel<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", fs.equals(fs));
        assertFalse("Not equal to null", fs.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", fs.equals(new String("abc")));
        FloatScalar.Abs<PositionUnit, LengthUnit> fsCounterPart =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(value, positionUnit);
        assertFalse("Not equal if one Absolute and other Relative", fs.equals(fsCounterPart));
        FloatScalar.Rel<TemperatureUnit> fsWrongBaseUnit = new FloatScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", fs.getSI(), fsWrongBaseUnit.getSI(), 0.0001f);
        assertFalse("Not equals because the standard SI unit differs", fs.equals(fsWrongBaseUnit));
        FloatScalar.Rel<LengthUnit> fsCompatibleUnit = new FloatScalar.Rel<LengthUnit>(38000.0f, LengthUnit.MILLIMETER);
        assertFalse("Units are different", fs.getUnit().equals(fsCompatibleUnit.getUnit()));
        assertTrue("equals returns true", fs.equals(fsCompatibleUnit));
        FloatScalar.Rel<LengthUnit> fsDifferentValue = new FloatScalar.Rel<LengthUnit>(123.456f, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", fs.equals(fsDifferentValue));
    }

    /**
     * Test the relational operations.
     */
    @Test
    public final void relOpRelTest()
    {
        FloatScalar.Rel<LengthUnit> base = new FloatScalar.Rel<LengthUnit>(123, LengthUnit.KILOMETER);
        FloatScalar.Rel<LengthUnit> same = new FloatScalar.Rel<LengthUnit>(123000, LengthUnit.METER);
        FloatScalar.Rel<LengthUnit> smaller = new FloatScalar.Rel<LengthUnit>(122999, LengthUnit.METER);
        FloatScalar.Rel<LengthUnit> larger = new FloatScalar.Rel<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertTrue("123km == 123000m", base.eq(same));
        assertFalse("NOT 123km != 123000m", base.ne(same));
        assertTrue("123km < 123001m", base.lt(larger));
        assertTrue("123km > 122999m", base.gt(smaller));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertFalse("NOT 123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km != 123001m", base.ne(larger));
        assertFalse("NOT 123km == 123001m", base.eq(larger));
        assertTrue("123km != 122999m", base.ne(smaller));
        assertFalse("NOT 123km == 122999m", base.eq(smaller));
        assertFalse("NOT 123km >= 123001m", base.ge(larger));
        assertFalse("NOT 123km <= 122999m", base.le(smaller));
    }

    /**
     * Test the Math functions.
     */
    @Test
    public final void mathFunctionsTestRelTest()
    {
        float[] seedValues = { -10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f };
        for (float seedValue : seedValues)
        {
            float input = seedValue;
            FloatScalar.Rel<LengthUnit> fs;
            fs = new FloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            MathTester.tester(input, "abs", fs.abs(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.abs(f);
                }
            });
            fs = new FloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            MathTester.tester(input, "ceil", fs.ceil(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.ceil(f);
                }
            });
            fs = new FloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            MathTester.tester(input, "floor", fs.floor(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.floor(f);
                }
            });
            fs = new FloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            MathTester.tester(input, "rint", fs.rint(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.rint(f);
                }
            });
            fs = new FloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            MathTester.tester(input, "round", fs.round(), 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.round(f);
                }
            });
        }
    }

    /**
     * Test plus(FloatScalarRel, FloatScalarRel).
     */
    @Test
    public final void binaryplusOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> result = FloatScalar.plus(left, right);
        assertEquals("value of element should be SI plus of contributing elements", left.getSI() + right.getSI(),
                result.getSI(), 0.001f);
    }

    /**
     * Test minus(FloatScalarRel, FloatScalarRel).
     */
    @Test
    public final void binaryminusOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> result = FloatScalar.minus(left, right);
        assertEquals("value of element should be SI minus of contributing elements", left.getSI() - right.getSI(),
                result.getSI(), 0.001f);
    }

    /**
     * Test multiply(FloatScalarRel, FloatScalarRel).
     */
    @Test
    public final void binarymultiplyOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        FloatScalar.Rel<?> result = FloatScalar.multiply(left, right);
        assertEquals("value of element should be SI multiply of contributing elements", left.getSI() * right.getSI(),
                result.getSI(), 0.001f);
    }

    /**
     * Test divide(FloatScalarRel, FloatScalarRel).
     */
    @Test
    public final void binarydivideOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        FloatScalar.Rel<?> result = FloatScalar.divide(left, right);
        assertEquals("value of element should be SI divide of contributing elements", left.getSI() / right.getSI(),
                result.getSI(), 0.001f);
    }

    /** */
    interface FloatToFloat
    {
        /**
         * @param f float; value
         * @return float value
         */
        float function(float f);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValue float; unprocessed value
         * @param operation String; description of method that is being tested
         * @param actualResult FloatScalar&lt;?&gt;; the actual result of the operation
         * @param precision double; expected accuracy
         * @param function FloatToFloat; encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final float inputValue, final String operation, final AbstractFloatScalar<?, ?> actualResult,
                final double precision, final FloatToFloat function)
        {
            float expectedResult = function.function(inputValue);
            float got = actualResult.getSI();
            String description = String.format("%s(%f->%f should be equal to %f with precision %f", operation, inputValue,
                    expectedResult, got, precision);
            // System.out.println(description);
            assertEquals(description, expectedResult, got, precision);
        }

    }

}
