package org.djunits4.value.vdouble.matrix;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import org.djunits4.unit.AbsoluteTemperatureUnit;
import org.djunits4.unit.LengthUnit;
import org.djunits4.unit.PositionUnit;
import org.djunits4.unit.TemperatureUnit;
import org.djunits4.unit.Unit;
import org.djunits4.value.ValueRuntimeException;
import org.djunits4.value.storage.StorageType;
import org.djunits4.value.vdouble.scalar.base.DoubleScalar;
import org.junit.Test;

/**
 * Test the DoubleMatrix class.
 * <p>
 * This file was generated by the djunits value test classes generator, 26 jun, 2015
 * <p>
 * Copyright (c) 2015-2019 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="https://djunits.org/docs/license.html">DJUNITS License</a>.
 * <p>
 * @author <a href="https://www.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="https://www.tudelft.nl/staff/p.knoppers/">Peter Knoppers</a>
 */
public class DoubleMatrixDenseTest
{
    /**
     * Generate test data.
     * @param rows int; the number of rows in the result
     * @param columns int; the number of columns in the result
     * @param nonRectangular boolean; if true; return a non-rectangular array; if false; return a rectangular array
     * @param startValue double; seed value
     * @return double[][]
     */
    private static double[][] data(final int rows, final int columns, final boolean nonRectangular, final double startValue)
    {
        double[][] result = new double[rows][];
        final int badRowIndex = nonRectangular ? rows - 1 : -1;
        for (int row = 0; row < rows; row++)
        {
            result[row] = new double[row == badRowIndex ? columns + 1 : columns];
            for (int column = 0; column < result[row].length; column++)
            {
                result[row][column] = row * 1000 + column + startValue;
            }
        }
        return result;
    }

    /**
     * Check that the values in a DoubleMatrixmatch the expected values.
     * @param dm DoubleMatrix&lt;?&gt;; the DoubleMatrix to match
     * @param reference double[][]; the reference values
     * @param precision double; the maximum allowed error
     * @param u Unit&lt;?&gt;; the expected type
     * @param expectAbsolute boolean; if true; dm should be Absolute; if false; dm should be Relative
     */
    private static void checkContentsAndType(final AbstractDoubleMatrix<?, ?> dm, final double[][] reference,
            final double precision, final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue("DoubleMatrix should not be null", null != dm);
        for (int row = dm.rows(); --row >= 0;)
        {
            for (int column = dm.cols(); --column >= 0;)
            {
                try
                {
                    assertEquals("Value should match", reference[row][column], dm.getInUnit(row, column), precision);
                }
                catch (ValueRuntimeException exception)
                {
                    fail("Unexpected exception");
                }
            }
        }
        assertEquals("Unit should be " + u.toString(), u, dm.getUnit());
        assertTrue("Should be " + (expectAbsolute ? "Absolute" : "Relative"),
                expectAbsolute ? dm.isAbsolute() : dm.isRelative());
    }

    /**
     * Compare the contents of two 2D arrays.
     * @param reference double[][]; the reference values
     * @param result double[][]; the actual values
     */
    public static void compareMatrix(double[][] reference, double[][] result)
    {
        assertEquals("number of rows should match", reference.length, result.length);
        for (int row = 0; row < reference.length; row++)
        {
            assertEquals("number of cols should match", reference[row].length, result[row].length);
            assertEquals("2D array is not jagged", reference[row].length, reference[0].length);
            for (int column = 0; column < reference[row].length; column++)
            {
                assertEquals("Value should match", reference[row][column], result[row][column], 0.001);
            }
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringAbsTest()
    {
        try
        {
            AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.KELVIN;
            double[][] value = data(3, 5, false, 38.0);
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> dm =
                    new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            String result = dm.toString(true, true);
            assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringMutableAbsTest()
    {
        try
        {
            AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.KELVIN;
            double[][] value = data(3, 5, false, 38.0);
            MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> dm =
                    new MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            String result = dm.toString(true, true);
            assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings({"unchecked"})
    @Test
    public final void basicsAbsTest()
    {
        try
        {
            AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.DEGREE_CELSIUS;
            double[][] value = data(3, 5, false, 38.0);
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> temperatureDM =
                    new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            checkContentsAndType(temperatureDM, value, 0.001, tempUnit, true);
            assertEquals("Value in SI is equivalent in Kelvin", 311.15, temperatureDM.getSI(0, 0), 0.05);
            assertEquals("Value in Fahrenheit", 100.4, temperatureDM.getInUnit(0, 0, AbsoluteTemperatureUnit.DEGREE_FAHRENHEIT),
                    0.1);
            compareMatrix(value, temperatureDM.getValuesInUnit());
            MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> mdm =
                    new MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            checkContentsAndType(mdm, value, 0.001, tempUnit, true);
            mdm.setSI(0, 0, 73);
            double safe = value[0][0];
            value[0][0] = -200; // Approximate Celsius equivalent of 73 Kelvin
            checkContentsAndType(mdm, value, 1, tempUnit, true);
            value[0][0] = safe; // Restore
            mdm.set(0, 0, temperatureDM.get(0, 0));
            checkContentsAndType(mdm, value, 0.001, tempUnit, true);
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> temperature2DM =
                    new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(temperatureDM.getValuesSI(),
                            AbsoluteTemperatureUnit.KELVIN, StorageType.DENSE);
            assertTrue("temperature2DM should be equal to temperatureDM", temperature2DM.equals(temperatureDM));
            assertTrue("Value is Absolute", temperatureDM.isAbsolute());
            assertFalse("Value is not Relative", temperatureDM.isRelative());
            temperatureDM = new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value,
                    AbsoluteTemperatureUnit.KELVIN, StorageType.DENSE);
            checkContentsAndType(temperatureDM, value, 0.001, AbsoluteTemperatureUnit.KELVIN, true);
            compareMatrix(value, temperatureDM.getValuesSI());
            FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>[][] scalar = new FloatScalar.Abs[value.length][];
            for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.Abs[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    scalar[row][column] = new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value[row][column],
                            AbsoluteTemperatureUnit.DEGREE_CELSIUS);
                }
            }
            temperatureDM = new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(scalar, StorageType.DENSE);
            checkContentsAndType(temperatureDM, value, 0.001, tempUnit, true);
            assertEquals("All cells != 0; cardinality should equal number of cells", value.length * value[0].length,
                    temperatureDM.cardinality());
            double sum = 0;
            for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.Abs[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    sum += temperatureDM.getSI(row, column);
                }
            }
            assertEquals("zSum should be sum of all values", sum, temperatureDM.zSum(), 0.001);
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @Test
    public final void toMutableAndBackAbsTest()
    {
        try
        {
            AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.DEGREE_CELSIUS;
            double[][] value = data(3, 5, false, 38.0);
            double[][] value2 = data(3, 5, false, 38.0);
            value2[0][0] = 12345;
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> dm =
                    new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> dmCopy = dm;
            MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> mdm = dm.mutable();
            checkContentsAndType(dm, value, 0.001, tempUnit, true);
            checkContentsAndType(mdm, value, 0.001, tempUnit, true);
            checkContentsAndType(dmCopy, value, 0.001, tempUnit, true);
            MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> mdmCopy = mdm.copy();
            checkContentsAndType(mdmCopy, value, 0.001, tempUnit, true);
            MutableDoubleMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> mmdm = mdm.mutable();
            checkContentsAndType(mmdm, value, 0.001, tempUnit, true);
            assertEquals("hashCode is independent on mutability", dm.hashCode(), mdm.hashCode());
            // Modify mdm
            mdm.setInUnit(0, 0, 12345, AbsoluteTemperatureUnit.DEGREE_CELSIUS);
            checkContentsAndType(dm, value, 0.001, tempUnit, true);
            checkContentsAndType(mdm, value2, 0.01, tempUnit, true);
            checkContentsAndType(mdmCopy, value, 0.001, tempUnit, true);
            checkContentsAndType(mmdm, value, 0.001, tempUnit, true);
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> idm = mdm.immutable();
            assertTrue("Different value extremely likely results in different hashCode", dm.hashCode() != mdm.hashCode());
            // Restore value of mdm
            mdm.setSI(0, 0, dm.getSI(0, 0));
            checkContentsAndType(idm, value2, 0.01, tempUnit, true);
            checkContentsAndType(mdm, value, 0.001, tempUnit, true);
            checkContentsAndType(mmdm, value, 0.001, tempUnit, true);
            mmdm.setSI(0, 0, 0);
            checkContentsAndType(mdm, value, 0.001, tempUnit, true);
            assertEquals("value should be about -273", -273, mmdm.getInUnit(0, 0, tempUnit), 0.2);
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test the equals method.
     */
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        PositionUnit positionUnit = PositionUnit.DEFAULT;
        double value = 38.0;
        FloatScalar.Abs<PositionUnit, LengthUnit> dm = new FloatScalar.Abs<PositionUnit, LengthUnit>(value, positionUnit);
        assertTrue("Equal to itself", dm.equals(dm));
        assertFalse("Not equal to null", dm.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", dm.equals(new String("abc")));
        FloatScalar.ImmutableRel<LengthUnit> dmCounterPart = new FloatScalar.ImmutableRel<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", dm.equals(dmCounterPart));
        FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit> dmWrongBaseUnit =
                new FloatScalar.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(value, AbsoluteTemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", dm.getSI(), dmWrongBaseUnit.getSI(), 0.0001);
        assertFalse("Not equals because the standard SI unit differs", dm.equals(dmWrongBaseUnit));
        FloatScalar.Abs<PositionUnit, LengthUnit> dmCompatibleUnit =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(38000.0, PositionUnit.MILLIMETER);
        assertFalse("Units are different", dm.getUnit().equals(dmCompatibleUnit.getUnit()));
        assertTrue("equals returns true", dm.equals(dmCompatibleUnit));
        FloatScalar.Abs<PositionUnit, LengthUnit> dmDifferentValue =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(123.456, PositionUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", dm.equals(dmDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        double[] seedValues = {-10, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 10};
        for (double seedValue : seedValues)
        {
            double[][] input = data(3, 5, false, seedValue);
            MutableDoubleMatrix.Abs<PositionUnit, LengthUnit> dm;
            try
            {
                dm = new MutableDoubleMatrix.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER, StorageType.DENSE);
                dm.ceil();
                MathTester.tester(input, "ceil", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.ceil(d);
                    }
                });
                dm = new MutableDoubleMatrix.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER, StorageType.DENSE);
                dm.floor();
                MathTester.tester(input, "floor", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.floor(d);
                    }
                });
                dm = new MutableDoubleMatrix.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER, StorageType.DENSE);
                dm.rint();
                MathTester.tester(input, "rint", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.rint(d);
                    }
                });
                dm = new MutableDoubleMatrix.Abs<PositionUnit, LengthUnit>(input, PositionUnit.METER, StorageType.DENSE);
                dm.round();
                MathTester.tester(input, "round", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.round(d);
                    }
                });
            }
            catch (ValueRuntimeException ve)
            {
                fail("Caught unexpected ValueException: " + ve.toString());
            }
        }
    }

    /**
     * Test plus(DoubleMatrixAbs.Dense, DoubleMatrixRel.Dense).
     */
    @Test
    public final void binaryplusOfAbsDenseAndRelDenseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.Abs<PositionUnit, LengthUnit> left =
                    new FloatMatrix.Abs<PositionUnit, LengthUnit>(leftValue, PositionUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.Abs<?, ?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements",
                            left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleMatrixAbs.Dense, DoubleMatrixRel.Dense).
     */
    @Test
    public final void binaryminusOfAbsDenseAndRelDenseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.Abs<PositionUnit, LengthUnit> left =
                    new FloatMatrix.Abs<PositionUnit, LengthUnit>(leftValue, PositionUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.Abs<?, ?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements",
                            left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test plus(DoubleMatrixAbs.Dense, DoubleMatrixRel.Sparse).
     */
    @Test
    public final void binaryplusOfAbsDenseAndRelSparseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.Abs<PositionUnit, LengthUnit> left =
                    new FloatMatrix.Abs<PositionUnit, LengthUnit>(leftValue, PositionUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            FloatMatrix.Abs<?, ?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements",
                            left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleMatrixAbs.Dense, DoubleMatrixRel.Sparse).
     */
    @Test
    public final void binaryminusOfAbsDenseAndRelSparseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.Abs<PositionUnit, LengthUnit> left =
                    new FloatMatrix.Abs<PositionUnit, LengthUnit>(leftValue, PositionUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            FloatMatrix.Abs<?, ?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements",
                            left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that malformed or mismatching arrays throw a ValueException.
     */
    @Test
    public final void sizeCheckAbsTest()
    {
        int junk = 0;
        try
        {
            // null array
            new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>((double[][]) null,
                    AbsoluteTemperatureUnit.DEGREE_FAHRENHEIT, StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on first row
            double[][] in = data(3, 5, false, 12.3);
            in[0] = null;
            new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(in, AbsoluteTemperatureUnit.DEGREE_CELSIUS,
                    StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on last row
            double[][] in = data(3, 5, false, 12.3);
            in[in.length - 1] = null;
            new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(in, AbsoluteTemperatureUnit.DEGREE_CELSIUS,
                    StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Non-rectangular array
            double[][] in = data(3, 5, true, 12.3);
            new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(in, AbsoluteTemperatureUnit.DEGREE_CELSIUS,
                    StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        // Determinant of non-square Matrix
        double[][] in = data(3, 5, false, 12.3);
        try
        {
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> matrix = null;
            try
            {
                matrix = new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(in,
                        AbsoluteTemperatureUnit.DEGREE_CELSIUS, StorageType.DENSE);
            }
            catch (ValueRuntimeException ve)
            {
                fail("Caught unexpected exception: " + ve.toString());
            }
            matrix.determinant();
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        assertTrue("The variable junk is only used to suppress annoying warnings of the code checker", junk > 0);
    }

    /**
     * Test the det method that computes and returns the determinant.
     */
    @Test
    public final void determinantAbsTest()
    {
        try
        {
            double[][] values = {{1, 2, 3}, {3, 5, 7}, {5, 10, 0}};
            FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit> matrix =
                    new FloatMatrix.Abs<AbsoluteTemperatureUnit, TemperatureUnit>(values, AbsoluteTemperatureUnit.KELVIN,
                            StorageType.DENSE);
            assertEquals("Determinant should be 15", 15, matrix.determinant(), 0.001);
        }
        catch (ValueRuntimeException ve)
        {
            if (ve.toString().contains("Matrix must be sparse"))
            {
                System.err.println("Ignoring bug in COLT library");
                return;
            }
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
            double[][] value = data(3, 5, false, 38.0);
            FloatMatrix.ImmutableRel<TemperatureUnit> dm = new FloatMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            String result = dm.toString(true, true);
            assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringMutableRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
            double[][] value = data(3, 5, false, 38.0);
            MutableDoubleMatrix.ImmutableRel<TemperatureUnit> dm =
                    new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            String result = dm.toString(true, true);
            assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Mutable \"", result.startsWith("Mutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings({"static-method", "unchecked"})
    @Test
    public final void basicsRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[][] value = data(3, 5, false, 38.0);
            FloatMatrix.ImmutableRel<TemperatureUnit> temperatureDM =
                    new FloatMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            checkContentsAndType(temperatureDM, value, 0.001, tempUnit, false);
            assertEquals("Value in SI is equivalent in Kelvin", 38.0, temperatureDM.getSI(0, 0), 0.05);
            assertEquals("Value in Fahrenheit", 38.0 * 9.0 / 5.0,
                    temperatureDM.getInUnit(0, 0, TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
            compareMatrix(value, temperatureDM.getValuesInUnit());
            MutableDoubleMatrix.ImmutableRel<TemperatureUnit> mdm =
                    new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            checkContentsAndType(mdm, value, 0.001, tempUnit, false);
            FloatMatrix.ImmutableRel<TemperatureUnit> temperature2DM = new FloatMatrix.ImmutableRel<TemperatureUnit>(
                    temperatureDM.getValuesSI(), TemperatureUnit.KELVIN, StorageType.DENSE);
            assertTrue("temperature2DM should be equal to temperatureDM", temperature2DM.equals(temperatureDM));
            assertTrue("Value is Relative", temperatureDM.isRelative());
            assertFalse("Value is not Absolute", temperatureDM.isAbsolute());
            temperatureDM = new FloatMatrix.ImmutableRel<TemperatureUnit>(value, TemperatureUnit.KELVIN, StorageType.DENSE);
            checkContentsAndType(temperatureDM, value, 0.001, TemperatureUnit.KELVIN, false);
            compareMatrix(value, temperatureDM.getValuesSI());
            FloatScalar.ImmutableRel<TemperatureUnit>[][] scalar = new FloatScalar.ImmutableRel[value.length][];
            for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.ImmutableRel[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    scalar[row][column] =
                            new FloatScalar.ImmutableRel<TemperatureUnit>(value[row][column], TemperatureUnit.DEGREE_CELSIUS);
                }
            }
            temperatureDM = new FloatMatrix.ImmutableRel<TemperatureUnit>(scalar, StorageType.DENSE);
            checkContentsAndType(temperatureDM, value, 0.001, tempUnit, false);
            assertEquals("All cells != 0; cardinality should equal number of cells", value.length * value[0].length,
                    temperatureDM.cardinality());
            double sum = 0;
            for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.ImmutableRel[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    sum += temperatureDM.getSI(row, column);
                }
            }
            assertEquals("zSum should be sum of all values", sum, temperatureDM.zSum(), 0.001);
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @Test
    public final void toMutableAndBackRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[][] value = data(3, 5, false, 38.0);
            double[][] value2 = data(3, 5, false, 38.0);
            value2[0][0] = 12345;
            FloatMatrix.ImmutableRel<TemperatureUnit> dm = new FloatMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            FloatMatrix.ImmutableRel<TemperatureUnit> dmCopy = dm;
            MutableDoubleMatrix.ImmutableRel<TemperatureUnit> mdm = dm.mutable();
            checkContentsAndType(dm, value, 0.001, tempUnit, false);
            checkContentsAndType(mdm, value, 0.001, tempUnit, false);
            checkContentsAndType(dmCopy, value, 0.001, tempUnit, false);
            MutableDoubleMatrix.ImmutableRel<TemperatureUnit> mdmCopy = mdm.copy();
            checkContentsAndType(mdmCopy, value, 0.001, tempUnit, false);
            MutableDoubleMatrix.ImmutableRel<TemperatureUnit> mmdm = mdm.mutable();
            checkContentsAndType(mmdm, value, 0.001, tempUnit, false);
            assertEquals("hashCode is independent on mutability", dm.hashCode(), mdm.hashCode());
            // Modify mdm
            mdm.setInUnit(0, 0, 12345, TemperatureUnit.DEGREE_CELSIUS);
            checkContentsAndType(dm, value, 0.001, tempUnit, false);
            checkContentsAndType(mdm, value2, 0.01, tempUnit, false);
            checkContentsAndType(mdmCopy, value, 0.001, tempUnit, false);
            checkContentsAndType(mmdm, value, 0.001, tempUnit, false);
            FloatMatrix.ImmutableRel<TemperatureUnit> idm = mdm.immutable();
            assertTrue("Different value extremely likely results in different hashCode", dm.hashCode() != mdm.hashCode());
            // Restore value of mdm
            mdm.setSI(0, 0, dm.getSI(0, 0));
            checkContentsAndType(idm, value2, 0.01, tempUnit, false);
            checkContentsAndType(mdm, value, 0.001, tempUnit, false);
            checkContentsAndType(mmdm, value, 0.001, tempUnit, false);
            mmdm.setSI(0, 0, 0);
            checkContentsAndType(mdm, value, 0.001, tempUnit, false);
            mdm.set(0, 0, new FloatScalar.ImmutableRel<TemperatureUnit>(value2[0][0], TemperatureUnit.KELVIN));
            checkContentsAndType(mdm, value2, 0.01, tempUnit, false);
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test the equals method.
     */
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        PositionUnit positionUnit = PositionUnit.DEFAULT;
        double value = 38.0;
        FloatScalar.ImmutableRel<LengthUnit> dm = new FloatScalar.ImmutableRel<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", dm.equals(dm));
        assertFalse("Not equal to null", dm.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", dm.equals(new String("abc")));
        FloatScalar.Abs<PositionUnit, LengthUnit> dmCounterPart =
                new FloatScalar.Abs<PositionUnit, LengthUnit>(value, positionUnit);
        assertFalse("Not equal if one Absolute and other Relative", dm.equals(dmCounterPart));
        FloatScalar.ImmutableRel<TemperatureUnit> dmWrongBaseUnit =
                new FloatScalar.ImmutableRel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", dm.getSI(), dmWrongBaseUnit.getSI(), 0.0001);
        assertFalse("Not equals because the standard SI unit differs", dm.equals(dmWrongBaseUnit));
        FloatScalar.ImmutableRel<LengthUnit> dmCompatibleUnit = new FloatScalar.ImmutableRel<LengthUnit>(38000.0, LengthUnit.MILLIMETER);
        assertFalse("Units are different", dm.getUnit().equals(dmCompatibleUnit.getUnit()));
        assertTrue("equals returns true", dm.equals(dmCompatibleUnit));
        FloatScalar.ImmutableRel<LengthUnit> dmDifferentValue = new FloatScalar.ImmutableRel<LengthUnit>(123.456, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", dm.equals(dmDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @Test
    public final void mathFunctionsTestRelTest()
    {
        double[] seedValues = {-10, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 10};
        for (double seedValue : seedValues)
        {
            double[][] input = data(3, 5, false, seedValue);
            MutableDoubleMatrix.ImmutableRel<LengthUnit> dm;
            try
            {
                dm = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(input, LengthUnit.METER, StorageType.DENSE);
                dm.abs();
                MathTester.tester(input, "abs", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.abs(d);
                    }
                });
                dm = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(input, LengthUnit.METER, StorageType.DENSE);
                dm = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(input, LengthUnit.METER, StorageType.DENSE);
                dm.ceil();
                MathTester.tester(input, "ceil", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.ceil(d);
                    }
                });
                dm = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(input, LengthUnit.METER, StorageType.DENSE);
                dm.floor();
                MathTester.tester(input, "floor", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.floor(d);
                    }
                });
                dm = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(input, LengthUnit.METER, StorageType.DENSE);
                dm.rint();
                MathTester.tester(input, "rint", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.rint(d);
                    }
                });
                dm = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(input, LengthUnit.METER, StorageType.DENSE);
                dm.round();
                MathTester.tester(input, "round", dm, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.round(d);
                    }
                });
            }
            catch (ValueRuntimeException ve)
            {
                fail("Caught unexpected ValueException: " + ve.toString());
            }
        }
    }

    /**
     * Test plus(DoubleMatrixRel.Dense, DoubleMatrixRel.Dense).
     */
    @Test
    public final void binaryplusOfRelDenseAndRelDenseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.ImmutableRel<LengthUnit> left = new FloatMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements",
                            left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleMatrixRel.Dense, DoubleMatrixRel.Dense).
     */
    @Test
    public final void binaryminusOfRelDenseAndRelDenseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.ImmutableRel<LengthUnit> left = new FloatMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements",
                            left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(DoubleMatrixRel.Dense, DoubleMatrixRel.Dense).
     */
    @Test
    public final void binarytimesOfRelDenseAndRelDenseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.ImmutableRel<LengthUnit> left = new FloatMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<?> result = FloatMatrix.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI times of contributing elements",
                            left.getSI(i, j) * right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test plus(DoubleMatrixRel.Dense, DoubleMatrixRel.Sparse).
     */
    @Test
    public final void binaryplusOfRelDenseAndRelSparseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.ImmutableRel<LengthUnit> left = new FloatMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            FloatMatrix.ImmutableRel<?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements",
                            left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleMatrixRel.Dense, DoubleMatrixRel.Sparse).
     */
    @Test
    public final void binaryminusOfRelDenseAndRelSparseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.ImmutableRel<LengthUnit> left = new FloatMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            FloatMatrix.ImmutableRel<?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements",
                            left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(DoubleMatrixRel.Dense, DoubleMatrixRel.Sparse).
     */
    @Test
    public final void binarytimesOfRelDenseAndRelSparseTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            FloatMatrix.ImmutableRel<LengthUnit> left = new FloatMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            FloatMatrix.ImmutableRel<?> result = FloatMatrix.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI times of contributing elements",
                            left.getSI(i, j) * right.getSI(i, j), result.getSI(i, j), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that malformed or mismatching arrays throw a ValueException.
     */
    @Test
    public final void sizeCheckRelTest()
    {
        int junk = 0;
        try
        {
            // null array
            new FloatMatrix.ImmutableRel<TemperatureUnit>((double[][]) null, TemperatureUnit.DEGREE_FAHRENHEIT, StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on first row
            double[][] in = data(3, 5, false, 12.3);
            in[0] = null;
            new FloatMatrix.ImmutableRel<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS, StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on last row
            double[][] in = data(3, 5, false, 12.3);
            in[in.length - 1] = null;
            new FloatMatrix.ImmutableRel<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS, StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Non-rectangular array
            double[][] in = data(3, 5, true, 12.3);
            new FloatMatrix.ImmutableRel<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS, StorageType.DENSE);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        // Determinant of non-square Matrix
        double[][] in = data(3, 5, false, 12.3);
        try
        {
            FloatMatrix.ImmutableRel<TemperatureUnit> matrix = null;
            try
            {
                matrix = new FloatMatrix.ImmutableRel<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS, StorageType.DENSE);
            }
            catch (ValueRuntimeException ve)
            {
                fail("Caught unexpected exception: " + ve.toString());
            }
            matrix.determinant();
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueRuntimeException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        assertTrue("The variable junk is only used to suppress annoying warnings of the code checker", junk > 0);
    }

    /**
     * Test the det method that computes and returns the determinant.
     */
    @Test
    public final void determinantRelTest()
    {
        try
        {
            double[][] values = {{1, 2, 3}, {3, 5, 7}, {5, 10, 0}};
            FloatMatrix.ImmutableRel<TemperatureUnit> matrix =
                    new FloatMatrix.ImmutableRel<TemperatureUnit>(values, TemperatureUnit.KELVIN, StorageType.DENSE);
            assertEquals("Determinant should be 15", 15, matrix.determinant(), 0.001);
        }
        catch (ValueRuntimeException ve)
        {
            if (ve.toString().contains("Matrix must be sparse"))
            {
                System.err.println("Ignoring bug in COLT library");
                return;
            }
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test the incrementBy method.
     */
    @Test
    public final void incrementByTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            MutableDoubleMatrix.ImmutableRel<LengthUnit> left =
                    new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            MutableDoubleMatrix.ImmutableRel<LengthUnit> referenceLeft = left.copy();
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            left.incrementBy(right);
            for (int row = 0; row < leftValue.length; row++)
            {
                for (int col = 0; col < leftValue[row].length; col++)
                {
                    assertEquals("value of element should be sum of contributing elements",
                            referenceLeft.getSI(row, col) + right.getSI(row, col), left.getSI(row, col), 0.001);
                }
            }
            left = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            right = new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            left.incrementBy(right);
            for (int row = 0; row < leftValue.length; row++)
            {
                for (int col = 0; col < leftValue[row].length; col++)
                {
                    assertEquals("value of element should be sum of contributing elements",
                            referenceLeft.getSI(row, col) + right.getSI(row, col), left.getSI(row, col), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test the decrementBy method.
     */
    @Test
    public final void decrementByTest()
    {
        try
        {
            double[][] leftValue = data(3, 5, false, 123.4);
            double[][] rightValue = data(3, 5, false, 234.5);
            MutableDoubleMatrix.ImmutableRel<LengthUnit> left =
                    new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            MutableDoubleMatrix.ImmutableRel<LengthUnit> referenceLeft = left.copy();
            FloatMatrix.ImmutableRel<LengthUnit> right =
                    new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
            left.decrementBy(right);
            for (int row = 0; row < leftValue.length; row++)
            {
                for (int col = 0; col < leftValue[row].length; col++)
                {
                    assertEquals("value of element should be difference of contributing elements",
                            referenceLeft.getSI(row, col) - right.getSI(row, col), left.getSI(row, col), 0.001);
                }
            }
            left = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
            right = new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
            left.decrementBy(right);
            for (int row = 0; row < leftValue.length; row++)
            {
                for (int col = 0; col < leftValue[row].length; col++)
                {
                    assertEquals("value of element should be difference of contributing elements",
                            referenceLeft.getSI(row, col) - right.getSI(row, col), left.getSI(row, col), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test the multiplyBy method.
     */
    @Test
    public final void multiplyByTest()
    {
        try
        {
            for (boolean lastNanOrdering : new boolean[] {false, true})
            {
                double[][] leftValue = data(30, 50, false, 123.4);
                double[][] rightValue = data(30, 50, false, 234.5);
                leftValue[0][0] = Float.NaN;
                leftValue[0][1] = Float.NaN;
                rightValue[0][1] = Float.NaN;
                rightValue[0][2] = Float.NaN;
                if (lastNanOrdering)
                {
                    leftValue[29][49] = Float.NaN;
                    leftValue[29][48] = Float.NaN;
                    rightValue[29][48] = Float.NaN;
                    rightValue[29][47] = Float.NaN;
                }
                else
                {
                    rightValue[29][49] = Float.NaN;
                    rightValue[29][48] = Float.NaN;
                    leftValue[29][48] = Float.NaN;
                    leftValue[29][47] = Float.NaN;
                }
                MutableDoubleMatrix.ImmutableRel<LengthUnit> left =
                        new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
                MutableDoubleMatrix.ImmutableRel<LengthUnit> referenceLeft = left.copy();
                FloatMatrix.ImmutableRel<LengthUnit> right =
                        new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
                left.times(right);
                for (int row = 0; row < leftValue.length; row++)
                {
                    for (int col = 0; col < leftValue[row].length; col++)
                    {
                        assertEquals("value of element should be product of contributing elements",
                                referenceLeft.getSI(row, col) * right.getSI(row, col), left.getSI(row, col), 0.001);
                    }
                }
                left = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
                right = new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
                left.times(right);
                for (int row = 0; row < leftValue.length; row++)
                {
                    for (int col = 0; col < leftValue[row].length; col++)
                    {
                        assertEquals("value of element should be product of contributing elements",
                                referenceLeft.getSI(row, col) * right.getSI(row, col), left.getSI(row, col), 0.001);
                    }
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test the divideBy method.
     */
    @Test
    public final void divideByTest()
    {
        try
        {
            for (boolean lastNanOrdering : new boolean[] {false, true})
            {
                double[][] leftValue = data(30, 50, false, 123.4);
                double[][] rightValue = data(30, 50, false, 234.5);
                leftValue[0][0] = Float.NaN;
                leftValue[0][1] = Float.NaN;
                rightValue[0][1] = Float.NaN;
                rightValue[0][2] = Float.NaN;
                if (lastNanOrdering)
                {
                    leftValue[29][49] = Float.NaN;
                    leftValue[29][48] = Float.NaN;
                    rightValue[29][48] = Float.NaN;
                    rightValue[29][47] = Float.NaN;
                }
                else
                {
                    rightValue[29][49] = Float.NaN;
                    rightValue[29][48] = Float.NaN;
                    leftValue[29][48] = Float.NaN;
                    leftValue[29][47] = Float.NaN;
                }
                MutableDoubleMatrix.ImmutableRel<LengthUnit> left =
                        new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
                MutableDoubleMatrix.ImmutableRel<LengthUnit> referenceLeft = left.copy();
                FloatMatrix.ImmutableRel<LengthUnit> right =
                        new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.DENSE);
                left.divide(right);
                for (int row = 0; row < leftValue.length; row++)
                {
                    for (int col = 0; col < leftValue[row].length; col++)
                    {
                        double expect = referenceLeft.getSI(row, col) / right.getSI(row, col);
                        double got = left.getSI(row, col);
                        if (Double.isNaN(expect))
                        {
                            assertTrue("value of element should be NaN", Double.isNaN(got));
                        }
                        else if (Double.isInfinite(expect))
                        {
                            assertTrue("value of element should be infinite", Double.isInfinite(got));
                        }
                        else
                        {
                            assertEquals("value of element should be ratio of contributing elements", expect, got, 0.001);
                        }
                    }
                }
                left = new MutableDoubleMatrix.ImmutableRel<LengthUnit>(leftValue, LengthUnit.MILE, StorageType.DENSE);
                right = new FloatMatrix.ImmutableRel<LengthUnit>(rightValue, LengthUnit.MILE, StorageType.SPARSE);
                left.divide(right);
                for (int row = 0; row < leftValue.length; row++)
                {
                    for (int col = 0; col < leftValue[row].length; col++)
                    {
                        double expect = referenceLeft.getSI(row, col) / right.getSI(row, col);
                        double got = left.getSI(row, col);
                        if (Double.isNaN(expect))
                        {
                            assertTrue("value of element should be NaN", Double.isNaN(got));
                        }
                        else if (Double.isInfinite(expect))
                        {
                            assertTrue("value of element should be infinite", Double.isInfinite(got));
                        }
                        else
                        {
                            assertEquals("value of element should be ratio of contributing elements", expect, got, 0.001);
                        }
                    }
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test the incrementBy, decrementBy, multiplyBy and divideBy methods that take a scalar as second argument.
     */
    @Test
    public void modifyByScalar()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[][] value = data(3, 5, false, 38.0);
            double modifier = 8.76;
            MutableDoubleMatrix.ImmutableRel<TemperatureUnit> testMatrix =
                    new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.incrementBy(modifier);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value of element should be sum of contributing elements", value[row][col] + modifier,
                            testMatrix.getSI(row, col), 0.001);
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            FloatScalar.ImmutableRel<TemperatureUnit> modifierScalar = new FloatScalar.ImmutableRel<>(modifier, TemperatureUnit.DEGREE_CELSIUS);
            testMatrix.incrementBy(modifierScalar);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value of element should be sum of contributing elements", value[row][col] + modifier,
                            testMatrix.getInUnit(row, col), 0.01);
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.incrementBy(Double.NaN);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertTrue("incremented value should be NaN", Double.isNaN(testMatrix.getInUnit(row, col)));
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.decrementBy(modifier);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value of element should be difference of contributing elements", value[row][col] - modifier,
                            testMatrix.getSI(row, col), 0.001);
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.decrementBy(modifierScalar);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value of element should be difference of contributing elements", value[row][col] - modifier,
                            testMatrix.getInUnit(row, col), 0.01);
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.decrementBy(Double.NaN);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertTrue("incremented value should be NaN", Double.isNaN(testMatrix.getInUnit(row, col)));
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.times(modifier);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value of element should be product of contributing elements", value[row][col] * modifier,
                            testMatrix.getSI(row, col), 0.001);
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.times(Double.NaN);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertTrue("incremented value should be NaN", Double.isNaN(testMatrix.getInUnit(row, col)));
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.divide(modifier);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value of element should be dividend of contributing elements", value[row][col] / modifier,
                            testMatrix.getSI(row, col), 0.001);
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.divide(Float.NaN);
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertTrue("incremented value should be NaN", Double.isNaN(testMatrix.getInUnit(row, col)));
                }
            }
            testMatrix = new MutableDoubleMatrix.ImmutableRel<TemperatureUnit>(value, tempUnit, StorageType.DENSE);
            testMatrix.neg();
            for (int row = 0; row < value.length; row++)
            {
                for (int col = 0; col < value[row].length; col++)
                {
                    assertEquals("value should be negated", -value[row][col], testMatrix.getInUnit(row, col), 0.001);
                }
            }
        }
        catch (ValueRuntimeException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /** */
    interface DoubleToDouble
    {
        /**
         * @param d double; value
         * @return double value
         */
        double function(double d);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValues double[][]; unprocessed value
         * @param operation String; description of method that is being tested
         * @param actualResult DoubleMatrix&lt;?&gt;; the actual result of the operation
         * @param precision double; expected accuracy
         * @param function DoubleToDouble; encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final double[][] inputValues, final String operation,
                final AbstractDoubleMatrix<?, ?> actualResult, final double precision, final DoubleToDouble function)
        {
            for (int i = 0; i < inputValues.length; i++)
            {
                for (int j = 0; j < inputValues[i].length; j++)
                {
                    double expectedResult = function.function(inputValues[i][j]);
                    double got = 0;
                    try
                    {
                        got = actualResult.getSI(i, j);
                    }
                    catch (ValueRuntimeException ve)
                    {
                        fail("Caught unexpected exception: " + ve.toString());
                    }
                    String description = String.format("%s(%f->%f should be equal to %f with precision %f", operation,
                            inputValues[i][j], expectedResult, got, precision);
                    // System.out.println(description);
                    assertEquals(description, expectedResult, got, precision);
                }
            }
        }

    }

}
